from aiogram import Router
from aiogram.types import CallbackQuery, Message
from aiogram.fsm.context import FSMContext
from keyboards.inline import directions
from states.university import UserStates
from utils.openrouter import generate_universities
import logging
import re
logger = logging.getLogger(__name__)
router = Router()


@router.message(UserStates.cities)
async def process_cities(message: Message, state: FSMContext):
    cities = [city.strip() for city in message.text.split(",")]

    if len(cities) < 1 or len(cities) > 5:
        await message.answer("‚ö† –í–≤–µ–¥–∏—Ç–µ –æ—Ç 1 –¥–æ 5 –≥–æ—Ä–æ–¥–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–Ω–∞–ø—Ä–∏–º–µ—Ä: –ú–æ—Å–∫–≤–∞, –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥)")
        return

    await state.update_data(cities=cities)
    await message.answer("‚úÖ –ì–æ—Ä–æ–¥–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!", parse_mode="Markdown")
    await message.answer("üéì –í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:", reply_markup=directions)



@router.callback_query(lambda c: c.data.startswith("direction:"))
async def process_direction(callback: CallbackQuery, state: FSMContext):
    direction = callback.data.split(":")[1]
    direction_emoji = {
        "it": "üíª",
        "econ": "üìà",
        "med": "ü©∫"
    }.get(direction, "‚ùì")

    await state.update_data(direction=direction)

    if callback.message.text != f"{direction_emoji} –í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–∏ –±–∞–ª–ª—ã –µ–≥—ç –∏ –ø—Ä–µ–¥–º–µ—Ç—ã –≤ —Ç–∞–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ \n (–ü—Ä–æ—Ñ. –º–∞—Ç 100 \n –†—É—Å—Å–∫–∏–π —è–∑—ã–∫ 100\n –ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞ 100)":
        await callback.message.edit_text(f"{direction_emoji} –í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–∏ –±–∞–ª–ª—ã –µ–≥—ç –∏ –ø—Ä–µ–¥–º–µ—Ç—ã –≤ —Ç–∞–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ \n (–ü—Ä–æ—Ñ. –º–∞—Ç 100 \n –†—É—Å—Å–∫–∏–π —è–∑—ã–∫ 100\n –ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞ 100)")

    await state.set_state(UserStates.score)


@router.message(UserStates.score)
async def process_scores(message: Message, state: FSMContext):
    lines = [line.strip() for line in message.text.split("\n") if line.strip()]
    scores = {}

    for line in lines:
        match = re.match(r'^(.+?)\s+(\d+)$', line)
        if not match:
            await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ: {line}")
            return
        subject = match.group(1).strip()
        score = int(match.group(2))
        scores[subject] = score

    data = await state.get_data()
    data["scores"] = scores
    await state.clear()

    recommendations = await generate_universities(data)
    if not isinstance(recommendations, str):
        recommendations = "‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏"

    await message.answer("üéì –ü–æ–¥—Ö–æ–¥—è—â–∏–µ –≤—É–∑—ã:")
    await message.answer(recommendations)